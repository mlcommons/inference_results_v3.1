diff --git a/cmake/OpenMP.cmake b/cmake/OpenMP.cmake
index fec17da1f..7f81ae5a4 100644
--- a/cmake/OpenMP.cmake
+++ b/cmake/OpenMP.cmake
@@ -97,11 +97,9 @@ endif()
 
 # add flags unconditionally to always utilize openmp-simd for any threading runtime
 if(OpenMP_C_FOUND)
-    append(CMAKE_C_FLAGS ${OpenMP_C_FLAGS})
-endif()
-
-if(OpenMP_CXX_FOUND)
-    append(CMAKE_CXX_FLAGS ${OpenMP_CXX_FLAGS})
+    add_definitions(${OpenMP_C_FLAGS})
+elseif(OpenMP_CXX_FOUND)
+    add_definitions(${OpenMP_CXX_FLAGS})
 endif()
 
 if(DNNL_CPU_THREADING_RUNTIME MATCHES "OMP")
@@ -111,9 +109,7 @@ if(DNNL_CPU_THREADING_RUNTIME MATCHES "OMP")
         append(CMAKE_SHARED_LINKER_FLAGS "-fopenmp=libgomp")
         append(CMAKE_EXE_LINKER_FLAGS "-fopenmp=libgomp")
     elseif(OpenMP_CXX_FOUND)
-        if(MSVC AND CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
-            list(APPEND EXTRA_SHARED_LIBS ${OpenMP_CXX_LIBRARIES})
-        endif()
+	list(APPEND EXTRA_SHARED_LIBS ${OpenMP_CXX_LIBRARIES})
     else()
         message(${_omp_severity} "OpenMP library could not be found. "
             "Proceeding might lead to highly sub-optimal performance.")
diff --git a/cmake/options.cmake b/cmake/options.cmake
index 29854b3c2..734f81cfa 100644
--- a/cmake/options.cmake
+++ b/cmake/options.cmake
@@ -37,7 +37,7 @@ option(DNNL_ENABLE_CONCURRENT_EXEC
     CAUTION: enabling this option increases memory consumption."
     OFF) # disabled by default
 
-option(DNNL_ENABLE_PRIMITIVE_CACHE "enables primitive cache." ON)
+  option(DNNL_ENABLE_PRIMITIVE_CACHE "enables primitive cache." OFF)
     # enabled by default
 
 option(DNNL_USE_RT_OBJECTS_IN_PRIMITIVE_CACHE "If DNNL_ENABLE_PRIMITIVE_CACHE
diff --git a/include/oneapi/dnnl/dnnl.hpp b/include/oneapi/dnnl/dnnl.hpp
index 0a6fa01b2..0861880d6 100644
--- a/include/oneapi/dnnl/dnnl.hpp
+++ b/include/oneapi/dnnl/dnnl.hpp
@@ -572,6 +572,8 @@ enum class algorithm {
     eltwise_gelu_tanh = dnnl_eltwise_gelu_tanh,
     /// Elementwise: erf-based gelu
     eltwise_gelu_erf = dnnl_eltwise_gelu_erf,
+    /// Elementwise: erf-based gelu
+    eltwise_gelu_erf_2dts = dnnl_eltwise_gelu_erf_2dts,
     /// Elementwise: natural logarithm
     eltwise_log = dnnl_eltwise_log,
     /// Elementwise: clip
diff --git a/include/oneapi/dnnl/dnnl_types.h b/include/oneapi/dnnl/dnnl_types.h
index 372abee64..a7849df44 100644
--- a/include/oneapi/dnnl/dnnl_types.h
+++ b/include/oneapi/dnnl/dnnl_types.h
@@ -1462,6 +1462,8 @@ typedef enum {
     dnnl_eltwise_pow = 0x20,
     /// Eltwise: erf-based gelu
     dnnl_eltwise_gelu_erf = 0x30,
+    /// Eltwise: erf approximate gelu
+    dnnl_eltwise_gelu_erf_2dts = 0x35,
     /// Eltwise: round
     dnnl_eltwise_round = 0x40,
     /// Eltwise: logsigmoid
@@ -2440,6 +2442,8 @@ typedef struct {
     /// The kind of primitive. Used for self-identifying the primitive
     /// descriptor. Must be #dnnl_matmul.
     dnnl_primitive_kind_t primitive_kind;
+    // Hack for inner purpose
+    dnnl_prop_kind_t prop_kind;
     /// Source memory descriptor.
     dnnl_memory_desc_t src_desc;
     /// Weights memory descriptor.
diff --git a/src/common/c_types_map.hpp b/src/common/c_types_map.hpp
index 088410864..2efdc462e 100644
--- a/src/common/c_types_map.hpp
+++ b/src/common/c_types_map.hpp
@@ -90,6 +90,7 @@ const alg_kind_t eltwise_clip_v2 = dnnl_eltwise_clip_v2;
 const alg_kind_t eltwise_pow = dnnl_eltwise_pow;
 const alg_kind_t eltwise_gelu_tanh = dnnl_eltwise_gelu_tanh;
 const alg_kind_t eltwise_gelu_erf = dnnl_eltwise_gelu_erf;
+const alg_kind_t eltwise_gelu_erf_2dts = dnnl_eltwise_gelu_erf_2dts;
 const alg_kind_t eltwise_hardswish = dnnl_eltwise_hardswish;
 const alg_kind_t eltwise_relu_use_dst_for_bwd
         = dnnl_eltwise_relu_use_dst_for_bwd;
diff --git a/src/common/dnnl_debug_autogenerated.cpp b/src/common/dnnl_debug_autogenerated.cpp
index b39cc76b3..983a07b60 100644
--- a/src/common/dnnl_debug_autogenerated.cpp
+++ b/src/common/dnnl_debug_autogenerated.cpp
@@ -1117,6 +1117,7 @@ const char *dnnl_alg_kind2str(dnnl_alg_kind_t v) {
     if (v == dnnl_eltwise_exp) return "eltwise_exp";
     if (v == dnnl_eltwise_gelu_tanh) return "eltwise_gelu_tanh";
     if (v == dnnl_eltwise_gelu) return "eltwise_gelu";
+    if (v == dnnl_eltwise_gelu_erf_2dts) return "eltwise_gelu_approximation";
     if (v == dnnl_eltwise_swish) return "eltwise_swish";
     if (v == dnnl_eltwise_log) return "eltwise_log";
     if (v == dnnl_eltwise_clip) return "eltwise_clip";
diff --git a/src/common/math_utils.hpp b/src/common/math_utils.hpp
index ce999514e..2860357fb 100644
--- a/src/common/math_utils.hpp
+++ b/src/common/math_utils.hpp
@@ -407,7 +407,8 @@ inline bool is_eltwise_ok(
                       eltwise_logsigmoid, eltwise_mish, eltwise_logistic,
                       eltwise_exp, eltwise_gelu_tanh, eltwise_hardswish,
                       eltwise_swish, eltwise_log, eltwise_clip, eltwise_clip_v2,
-                      eltwise_pow, eltwise_gelu_erf, eltwise_round)
+                      eltwise_pow, eltwise_gelu_erf, eltwise_round,
+                      eltwise_gelu_erf_2dts)
             && IMPLICATION(alg == eltwise_bounded_relu, alpha >= 0)
             && IMPLICATION(
                     one_of(alg, eltwise_clip, eltwise_clip_v2), beta >= alpha)
diff --git a/src/common/primitive_exec_types.cpp b/src/common/primitive_exec_types.cpp
index c1eb03bd0..4c41d6271 100644
--- a/src/common/primitive_exec_types.cpp
+++ b/src/common/primitive_exec_types.cpp
@@ -60,7 +60,7 @@ status_t cvt_primitive_args(const primitive_desc_t *pd, int nargs,
         }
     }
 
-    if (n_inputs != pd->n_inputs() + extra_inputs) return invalid_arguments;
+    // if (n_inputs != pd->n_inputs() + extra_inputs) return invalid_arguments;
     if (n_outputs != pd->n_outputs() + extra_outputs) return invalid_arguments;
 
     return success;
diff --git a/src/cpu/gemm_inner_product_utils.cpp b/src/cpu/gemm_inner_product_utils.cpp
index dcd6dfea6..4104b30f6 100644
--- a/src/cpu/gemm_inner_product_utils.cpp
+++ b/src/cpu/gemm_inner_product_utils.cpp
@@ -139,13 +139,14 @@ void ref_pp_kernel_t::operator()(void *dst, const void *acc, const char *bias,
 
 pp_kernel_t::pp_kernel_t(size_t OC, size_t MB, dim_t dst_mb_stride,
         const primitive_attr_t *attr, data_type_t bias_dt, data_type_t acc_dt,
-        const memory_desc_t *dst_md, bool skip_sum)
+        const memory_desc_t *dst_md, bool skip_sum, bool pcomp)
     : OC_(OC)
     , MB_(MB)
     , dst_mb_stride_(dst_mb_stride)
     , bias_data_type_(bias_dt)
     , acc_data_type_(acc_dt)
     , dst_data_type_(dst_md->data_type)
+    , do_precompensation(pcomp && dst_data_type_ == data_type::s8)
     , ndims_(dst_md->ndims) {
     do_scale_ = !attr->output_scales_.has_default_values();
     if (do_scale_)
@@ -179,7 +180,7 @@ pp_kernel_t::pp_kernel_t(size_t OC, size_t MB, dim_t dst_mb_stride,
 
 pp_kernel_t *pp_kernel_t::create(size_t OC, size_t MB, dim_t dst_mb_stride,
         const primitive_attr_t *attr, data_type_t bias_dt, data_type_t acc_dt,
-        const memory_desc_t *dst_md, bool skip_sum) {
+        const memory_desc_t *dst_md, bool skip_sum, bool pcomp) {
 #if DNNL_X64
     auto *res = x64::inner_product_utils::jit_pp_kernel_create(
             OC, MB, dst_mb_stride, attr, bias_dt, acc_dt, dst_md, skip_sum);
diff --git a/src/cpu/gemm_inner_product_utils.hpp b/src/cpu/gemm_inner_product_utils.hpp
index d732180ef..5f986bdbe 100644
--- a/src/cpu/gemm_inner_product_utils.hpp
+++ b/src/cpu/gemm_inner_product_utils.hpp
@@ -32,12 +32,14 @@ namespace inner_product_utils {
 struct pp_kernel_t {
     static pp_kernel_t *create(size_t OC, size_t MB, dim_t dst_mb_stride,
             const primitive_attr_t *attr, data_type_t bias_dt,
-            data_type_t acc_dt, const memory_desc_t *dst_md, bool skip_sum);
+            data_type_t acc_dt, const memory_desc_t *dst_md, bool skip_sum, bool bcomp = false);
+
     static pp_kernel_t *create(
             const cpu_inner_product_fwd_pd_t *pd, bool skip_sum) {
+        auto bcomp = pd->desc()->prop_kind == prop_kind::forward_training;
         return create(pd->OC(), pd->MB(), pd->OC(), pd->attr(),
                 pd->desc()->bias_desc.data_type, pd->desc()->accum_data_type,
-                pd->dst_md(), skip_sum);
+                pd->dst_md(), skip_sum, bcomp);
     }
 
     virtual ~pp_kernel_t() = default;
@@ -59,7 +61,7 @@ struct pp_kernel_t {
 protected:
     pp_kernel_t(size_t OC, size_t MB, dim_t dst_mb_stride,
             const primitive_attr_t *attr, data_type_t bias_dt,
-            data_type_t acc_dt, const memory_desc_t *dst_md, bool skip_sum);
+            data_type_t acc_dt, const memory_desc_t *dst_md, bool skip_sum, bool pcomp = false);
 
     size_t OC_;
     size_t MB_;
@@ -76,6 +78,7 @@ protected:
     bool do_binary_ = false;
     bool do_sum_ = false;
     bool do_dst_zero_points_ = false;
+    bool do_precompensation = false;
     float sum_scale_ = 0.f;
     int32_t sum_zp_ = 0;
     data_type_t sum_data_type_;
diff --git a/src/cpu/matmul/gemm_x8s8s32x_matmul.hpp b/src/cpu/matmul/gemm_x8s8s32x_matmul.hpp
index 4df931ecf..f38f35215 100644
--- a/src/cpu/matmul/gemm_x8s8s32x_matmul.hpp
+++ b/src/cpu/matmul/gemm_x8s8s32x_matmul.hpp
@@ -71,13 +71,15 @@ struct gemm_x8s8s32x_matmul_t : public primitive_t {
                     mb = m_per_thr;
                 }
             }
+            auto pcomp =
+                pd()->desc()->prop_kind == prop_kind_t::dnnl_forward_training;
 
             CHECK(safe_ptr_assign(pp_kernel_,
                     inner_product_utils::pp_kernel_t::create(pd()->N(), mb,
                             pd()->ldc(), &pd()->params().pp_attr_,
                             pd()->desc()->bias_desc.data_type,
                             pd()->desc()->accum_data_type, pd()->dst_md(),
-                            false)));
+                            false, pcomp)));
             return pp_kernel_->create_kernel();
         }
         return status::success;
diff --git a/src/cpu/simple_q10n.hpp b/src/cpu/simple_q10n.hpp
index 09c478dec..be187e652 100644
--- a/src/cpu/simple_q10n.hpp
+++ b/src/cpu/simple_q10n.hpp
@@ -40,9 +40,9 @@ saturate(const acc_t &x) {
 template <typename data_t, typename acc_t>
 inline typename utils::enable_if<nstl::is_integral<data_t>::value,
         typename utils::remove_reference<acc_t>::type>::type
-saturate(const acc_t &x) {
+saturate(const acc_t &x, bool elevated_min = false) {
     acc_t v = x;
-    acc_t lbound = (acc_t)nstl::numeric_limits<data_t>::lowest();
+    acc_t lbound = (acc_t)nstl::numeric_limits<data_t>::lowest() + int(elevated_min);
     // Pick up a modified version of max value when do f32 -> s32.
     acc_t ubound = types::max_value<acc_t>(data_traits<data_t>::data_type);
     if (v < lbound) v = lbound;
@@ -51,12 +51,12 @@ saturate(const acc_t &x) {
 }
 
 template <>
-inline uint8_t saturate<int8_t, uint8_t>(const uint8_t &x) {
+inline uint8_t saturate<int8_t, uint8_t>(const uint8_t &x, bool) {
     return x <= 127u ? x : 127;
 }
 
 template <>
-inline int8_t saturate<uint8_t, int8_t>(const int8_t &x) {
+inline int8_t saturate<uint8_t, int8_t>(const int8_t &x, bool) {
     return x >= 0 ? x : 0;
 }
 
diff --git a/src/cpu/x64/brgemm/brgemm.cpp b/src/cpu/x64/brgemm/brgemm.cpp
index 1021c6d0d..98d320a7e 100644
--- a/src/cpu/x64/brgemm/brgemm.cpp
+++ b/src/cpu/x64/brgemm/brgemm.cpp
@@ -95,6 +95,8 @@ void brgemm_kernel_execute_postops(const brgemm_kernel_t *brg_kernel, int bs,
     brgemm_p.ptr_buf = scratch;
     brgemm_p.ptr_bias = post_ops_data.bias;
     brgemm_p.ptr_scales = post_ops_data.scales;
+    brgemm_p.f_scale = post_ops_data.f_scale;
+    brgemm_p.dummy = post_ops_data.f_scale;
     brgemm_p.do_post_ops = 1;
     brgemm_p.skip_accm = post_ops_data.skip_accumulation ? 1 : 0;
     brgemm_p.BS = bs;
diff --git a/src/cpu/x64/brgemm/brgemm_types.hpp b/src/cpu/x64/brgemm/brgemm_types.hpp
index e065053ec..fc3f0c023 100644
--- a/src/cpu/x64/brgemm/brgemm_types.hpp
+++ b/src/cpu/x64/brgemm/brgemm_types.hpp
@@ -183,6 +183,8 @@ struct brgemm_t {
     bool with_scales = false;
     bool with_comp_pads = false;
     bool req_s8s8_compensation = false;
+    bool skip_input_s8_compensation = false;
+    bool req_pre_compensation = false;
     brgemm_broadcast_t zp_type_a = brgemm_broadcast_t::none;
     brgemm_broadcast_t zp_type_b = brgemm_broadcast_t::none;
     brgemm_broadcast_t zp_type_c = brgemm_broadcast_t::none;
@@ -223,6 +225,8 @@ struct brgemm_kernel_params_t {
     void *ptr_D;
 
     const void *ptr_scales;
+    float f_scale;
+    float dummy;  /* HACK, for alignment */
     void *ptr_buf;
 
     size_t do_post_ops;
@@ -336,8 +340,30 @@ struct brgemm_post_ops_data_t {
         , skip_accumulation(skip_accumulation)
         , zp_a_val {zp_a_val} {}
 
+    brgemm_post_ops_data_t(const void *bias, const float *scales,
+            const float f_scale,
+            const void *binary_post_ops_rhs, size_t oc_logical_off,
+            const size_t dst_row_logical_off = 0, char *data_C_ptr_ = nullptr,
+            const size_t first_mb_matrix_addr_off = 0,
+            const void *a_zp_compensations = nullptr,
+            const void *b_zp_compensations = nullptr,
+            const void *c_zp_values = nullptr, bool skip_accumulation = false)
+        : bias(bias)
+        , scales(scales)
+        , f_scale(f_scale)
+        , binary_post_ops_rhs(binary_post_ops_rhs)
+        , oc_logical_off(oc_logical_off)
+        , dst_row_logical_off(dst_row_logical_off)
+        , data_C_ptr_(data_C_ptr_)
+        , first_mb_matrix_addr_off(first_mb_matrix_addr_off)
+        , a_zp_compensations(a_zp_compensations)
+        , b_zp_compensations(b_zp_compensations)
+        , c_zp_values(c_zp_values)
+        , skip_accumulation(skip_accumulation) {}
+
     const void *bias = nullptr;
     const float *scales = nullptr;
+    const float f_scale {1.f};
     const void *binary_post_ops_rhs = nullptr;
     size_t oc_logical_off = 0;
     size_t dst_row_logical_off = 0;
diff --git a/src/cpu/x64/brgemm/jit_brgemm_amx_uker.cpp b/src/cpu/x64/brgemm/jit_brgemm_amx_uker.cpp
index d16708e4e..aacc8b061 100644
--- a/src/cpu/x64/brgemm/jit_brgemm_amx_uker.cpp
+++ b/src/cpu/x64/brgemm/jit_brgemm_amx_uker.cpp
@@ -71,6 +71,7 @@ struct jit_brgemm_amx_uker_base_t : public jit_generator {
             eltwise_injector::static_params_t esp;
             esp.preserve_vmm = preserve_vmm;
             esp.preserve_p_table = false;
+            esp.dynamic_scale_off = reg_final_scale_offs;
 
             postops_injector_ = utils::make_unique<
                     injector::jit_uni_postops_injector_t<avx512_core>>(
@@ -135,7 +136,8 @@ private:
     constexpr static int reg_zp_comp_a_offs_ = 8;
     constexpr static int reg_zp_comp_b_offs_ = 16;
     constexpr static int reg_zp_c_values_offs_ = 24;
-    constexpr static int stack_space_needed_ = 32;
+    constexpr static int reg_final_scale_offs = 32;
+    constexpr static int stack_space_needed_ = 40;
 
     bool are_post_ops_applicable_ = false;
     bool need_to_apply_alpha_beta_ = false;
@@ -690,6 +692,9 @@ void jit_brgemm_amx_uker_base_t::prepare_post_ops_registers(
                     reg_scales, scales_offset(ldb_ind + ldb));
             vmovups(zmm_scales(ldb), scales_ptr);
         }
+        // TODO: Make f_scale pointer in the near future.
+        mov(reg_scales, ptr[param1 + GET_OFF(f_scale)]);
+        mov(ptr[rsp + reg_final_scale_offs], reg_scales);
     }
 }
 
diff --git a/src/cpu/x64/brgemm/jit_brgemm_kernel.cpp b/src/cpu/x64/brgemm/jit_brgemm_kernel.cpp
index a876bec6a..80ed9b85a 100644
--- a/src/cpu/x64/brgemm/jit_brgemm_kernel.cpp
+++ b/src/cpu/x64/brgemm/jit_brgemm_kernel.cpp
@@ -72,9 +72,13 @@ struct jit_brgemm_kernel_t : public jit_generator {
             const binary_injector::static_params_t bsp {
                     this->param1, enabled_bcast_strategy, rhs_sp};
 
+            const eltwise_injector::static_params_t esp {
+                (size_t) reg_final_scale_offs
+            };
+
             postops_injector_ = utils::make_unique<
                     injector::jit_uni_postops_injector_t<avx512_core>>(
-                    this, brg.attr->post_ops_, bsp);
+                    this, brg.attr->post_ops_, bsp, esp);
 
             using namespace dnnl::impl::cpu::binary_injector_utils;
             std::tie(with_binary_per_oc_bcast_, with_binary_per_oc_sp_bcast_,
@@ -206,6 +210,7 @@ private:
     constexpr static int reg_data_C_ptr_ = 184;
     constexpr static int reg_skip_accm_offs_ = 192;
     constexpr static int reg_zp_a_val_offs_ = 200;
+    constexpr static int reg_final_scale_offs = 200;
     constexpr static int stack_space_needed_ = 208;
 
     bool is_ldb_loop_ = false;
@@ -259,6 +264,8 @@ private:
             Xbyak::Opmask ktail_mask) const;
     Xbyak::Ymm ymm_mask(const Xbyak::Ymm ymm_in, bool mask_flag, bool store,
             Xbyak::Opmask ktail_mask) const;
+    Xbyak::Xmm xmm_mask(const Xbyak::Xmm xmm_in, bool mask_flag, bool store,
+            Xbyak::Opmask ktail_mask) const;
 
     void cvt2ps(data_type_t type_in, const Xbyak::Zmm zmm_in,
             const Xbyak::Operand &op, bool mask_flag, bool store,
@@ -779,6 +786,8 @@ void jit_brgemm_kernel_t::read_params() {
         mov(ptr[rsp + reg_bias_offs_], reg_bias);
     }
     if (brg.with_scales) {
+        mov(reg_scales, ptr[param1 + GET_OFF(f_scale)]);
+        mov(ptr[rsp + reg_final_scale_offs], reg_scales);
         mov(reg_scales, ptr[param1 + GET_OFF(ptr_scales)]);
         mov(ptr[rsp + reg_scales_offs_], reg_scales);
     }
@@ -1033,7 +1042,16 @@ void jit_brgemm_kernel_t::store_accumulators_apply_post_ops(
     auto zmm_ubound = zmm_tmp_2();
     if (dt_requires_saturation) {
         init_saturate_f32(
-                zmm_lbound, zmm_ubound, reg_tmp_gpr, data_type::f32, brg.dt_d);
+                zmm_lbound, zmm_ubound, reg_tmp_gpr, data_type::f32, brg.dt_d, true);
+    }
+
+    auto xmm_compensation = Xbyak::Xmm(zmm_tmp_3().getIdx());
+    if (brg.req_pre_compensation && brg.dt_d == data_type::s8) {
+        // Do we still need reg_bdb_loop???
+        mov(ptr[rsp + reg_bdb_loop_offs_], reg_bdb_loop);
+        mov(reg_s8_input_shift, 128);
+        vpbroadcastb(xmm_compensation, reg_s8_input_shift.cvt8());
+        mov(reg_bdb_loop, ptr[rsp + reg_bdb_loop_offs_]);
     }
 
     if (brg.is_bf16_emu) bf16_emu_->init_vcvtneps2bf16();
@@ -1064,7 +1082,19 @@ void jit_brgemm_kernel_t::store_accumulators_apply_post_ops(
                         vmovdqu16(addr, r_ymm);
                     }
                     break;
-                case data_type::s8: vpmovsdb(addr, r_zmm); break;
+                case data_type::s8: {
+                    // hack, may be two flags
+                    if (brg.req_pre_compensation) {
+                        auto xmm = Xbyak::Xmm(zmm.getIdx());
+                        vpmovsdb(xmm, zmm);
+                        vpxord(xmm, xmm, xmm_compensation);
+                        auto r_addr = addr | k_mask;
+                        vmovdqu8(r_addr, xmm);
+                    } else {
+                        vpmovsdb(addr, r_zmm);
+                    }
+                    break;
+                }
                 case data_type::u8: vpmovusdb(addr, r_zmm); break;
                 default: assert(!"unknown dst_dt");
             }
@@ -1159,7 +1189,7 @@ void jit_brgemm_kernel_t::store_accumulators_without_post_ops(
     auto zmm_ubound = zmm_tmp_2();
     if (dt_requires_saturation) {
         init_saturate_f32(
-                zmm_lbound, zmm_ubound, reg_tmp_gpr, data_type::f32, brg.dt_d);
+                zmm_lbound, zmm_ubound, reg_tmp_gpr, data_type::f32, brg.dt_d, true);
     }
 
     for (int bd = 0; bd < bd_block; bd++) {
@@ -1495,8 +1525,9 @@ void jit_brgemm_kernel_t::gemm_microkernel_avx512(int bd_block2,
             else if (brg.is_bf16 || brg.is_int8)
                 vpbroadcastd(z1, ptr[reg_aux_A + offset]);
         }
-
-        if (brg.req_s8s8_compensation) vpaddb(z1, z1, zmm_inp_shift());
+        // HACK !! Pre-compensate BRGEMM input at last quant
+        if (brg.req_s8s8_compensation && !brg.skip_input_s8_compensation)
+            vpaddb(z1, z1, zmm_inp_shift());
     };
 
     bool maybe_load_bytes = (rows_for_rd_tail > 0 || brg.brgattr.wary_tail_read)
@@ -1647,8 +1678,9 @@ void jit_brgemm_kernel_t::ldb_loop(int bd_block2, bool is_bdb_tail,
                 mov(reg_stride_lda, brg.typesize_A * brg.LDA);
                 mov(reg_stride_ldb, brg.rd_step * brg.typesize_B * brg.LDB);
             }
-
-            if (brg.req_s8s8_compensation) {
+            // HACK!! input already compensated or output need compensation?
+            if (brg.req_s8s8_compensation
+                    && !brg.skip_input_s8_compensation) {
                 mov(ptr[rsp + reg_bdb_loop_offs_], reg_bdb_loop);
                 mov(reg_s8_input_shift, 128);
                 vpbroadcastb(zmm_inp_shift(), reg_s8_input_shift.cvt8());
diff --git a/src/cpu/x64/injectors/jit_uni_eltwise_injector.cpp b/src/cpu/x64/injectors/jit_uni_eltwise_injector.cpp
index 4322a5bac..f2fa2c3d1 100644
--- a/src/cpu/x64/injectors/jit_uni_eltwise_injector.cpp
+++ b/src/cpu/x64/injectors/jit_uni_eltwise_injector.cpp
@@ -43,7 +43,7 @@ bool is_alg_supported(alg_kind_t alg) {
             eltwise_relu_use_dst_for_bwd, eltwise_tanh_use_dst_for_bwd,
             eltwise_elu_use_dst_for_bwd, eltwise_sqrt_use_dst_for_bwd,
             eltwise_logistic_use_dst_for_bwd, eltwise_exp_use_dst_for_bwd,
-            eltwise_clip_v2_use_dst_for_bwd);
+            eltwise_clip_v2_use_dst_for_bwd, eltwise_gelu_erf_2dts);
 }
 
 bool is_supported(cpu_isa_t isa, alg_kind_t alg) {
@@ -70,7 +70,7 @@ void jit_uni_eltwise_injector_f32<isa, Wmm>::injector_preamble(
             && utils::one_of(alg_, eltwise_tanh, eltwise_elu, eltwise_abs,
                     eltwise_soft_relu, eltwise_logsigmoid, eltwise_mish,
                     eltwise_logistic, eltwise_exp, eltwise_gelu_tanh,
-                    eltwise_swish, eltwise_gelu_erf,
+                    eltwise_swish, eltwise_gelu_erf, eltwise_gelu_erf_2dts,
                     eltwise_tanh_use_dst_for_bwd, eltwise_elu_use_dst_for_bwd,
                     eltwise_logistic_use_dst_for_bwd,
                     eltwise_exp_use_dst_for_bwd);
@@ -109,6 +109,11 @@ void jit_uni_eltwise_injector_f32<isa, Wmm>::injector_preamble(
     assert(preserved_gprs_count == aux_gprs_count());
 
     if (save_state_) {
+        // HACK!!!
+        if (dynamic_scale_off != -1) {
+          h->push(p_param);
+          h->mov(p_param, h->rsp);
+        }
         if (preserve_p_table_) h->push(p_table);
         for (size_t i = 0; i < preserved_gprs_count; ++i)
             h->push(Reg64(preserved_gpr_idxs[i]));
@@ -173,6 +178,11 @@ void jit_uni_eltwise_injector_f32<isa, Wmm>::injector_postamble() {
     for (int i = aux_gprs_count() - 1; i >= 0; --i)
         h->pop(Reg64(preserved_gpr_idxs[i]));
     if (preserve_p_table_) h->pop(p_table);
+
+    // HACK, restore stack
+    if (dynamic_scale_off != 0) {
+      h->pop(p_param);
+    }
 }
 
 template <cpu_isa_t isa, typename Wmm>
@@ -1165,6 +1175,39 @@ void jit_uni_eltwise_injector_f32<isa, Wmm>::gelu_erf_compute_vector_fwd(
     h->uni_vfmadd213ps(vmm_src, vmm_aux3, vmm_aux3);
 }
 
+template <cpu_isa_t isa, typename Wmm>
+void jit_uni_eltwise_injector_f32<isa, Wmm>::gelu_erf_2dts_compute_vector_fwd(
+        const Vmm &vmm_src) {
+    // Compute gelu using 2nd order polynormial solution
+    // Parameters from libxsmm and i-bert
+
+    // aux1 = x * rsqrt(2)
+    h->uni_vmulps(vmm_aux1, vmm_src, table_val(gelu_erf_one_over_sqrt_two));
+    // aux3 = x * rsqrt(2)
+    h->uni_vmovups(vmm_aux3, vmm_aux1);
+    // aux0 get sign
+    h->uni_vandps(vmm_aux0, vmm_aux1, table_val(sign_mask));
+
+    // aux1 = abs(x * rsqrt(2))
+    abs_compute_vector_fwd(vmm_aux1);
+    // aux2 = confine aux1 in [0, nb)
+    h->uni_vminps(vmm_aux2, vmm_aux1, table_val(gelu_erf_nb));
+
+    // compute 2nd order polynomial
+    // abs_erf = (a * aux2 + b) * aux2 + c
+    h->uni_vmovups(vmm_aux1, table_val(gelu_erf_a));
+    h->uni_vfmadd213ps(vmm_aux1, vmm_aux2, table_val(gelu_erf_b));
+    h->uni_vfmadd213ps(vmm_aux1, vmm_aux2, table_val(gelu_erf_c));
+
+    // sign erf
+    h->uni_vxorps(vmm_src, vmm_aux1, vmm_aux0);
+
+    // S = 0.5 * s = x / sqrt^2(2)
+    h->uni_vmulps(vmm_aux3, vmm_aux3, table_val(gelu_erf_one_over_sqrt_two));
+    // GELU = 0.5 * s * (1 + erf) = S + S * erf
+    h->uni_vfmadd213ps(vmm_src, vmm_aux3, vmm_aux3);
+}
+
 template <cpu_isa_t isa, typename Wmm>
 void jit_uni_eltwise_injector_f32<isa, Wmm>::relu_compute_vector_bwd(
         const Vmm &vmm_src) {
@@ -1582,6 +1625,7 @@ size_t jit_uni_eltwise_injector_f32<isa, Wmm>::aux_vecs_count() {
             case eltwise_clip_v2: return 0;
             case eltwise_pow: return 2;
             case eltwise_gelu_erf: return 5;
+            case eltwise_gelu_erf_2dts: return 5; // Maybe 4???
             case eltwise_round: return 0;
             case eltwise_hardswish: return 1;
             default: assert(!"unsupported eltwise algorithm");
@@ -1675,6 +1719,9 @@ void jit_uni_eltwise_injector_f32<isa, Wmm>::compute_body(
                 case eltwise_gelu_erf:
                     gelu_erf_compute_vector_fwd(Vmm(idx));
                     break;
+                case eltwise_gelu_erf_2dts:
+                    gelu_erf_2dts_compute_vector_fwd(Vmm(idx));
+                    break;
                 case eltwise_round: round_compute_vector_fwd(Vmm(idx)); break;
                 case eltwise_hardswish:
                     hardswish_compute_vector_fwd(Vmm(idx));
@@ -1729,7 +1776,12 @@ void jit_uni_eltwise_injector_f32<isa, Wmm>::compute_body(
             }
         }
         if (scale_ != 1.f) {
+          if (dynamic_scale_off != -1) {
+            // HACK, only for AVX512F +
+            h->vmulps(Vmm(idx), Vmm(idx), stack_val(dynamic_scale_off));
+          } else {
             h->uni_vmulps(Vmm(idx), Vmm(idx), table_val(scale));
+          }
         }
     });
 }
@@ -2121,6 +2173,14 @@ void jit_uni_eltwise_injector_f32<isa, Wmm>::register_table_entries() {
             {gelu_erf_pol, {0x3f87dc22, true}}, // p5 = 1.061405429f
     };
 
+    // gelu_erf(x) low-precision polynomial approximation
+    static const table_t gelu_erf_2dts {
+            {gelu_erf_a, {0xbe93dd98, true}}, // a = -0.2888f
+            {gelu_erf_b, {0x3f82c981, true}}, // b = 1.0217744f
+            {gelu_erf_c, {0x3dc519c3, true}}, // c = 0.0962405432f
+            {gelu_erf_nb, {0x3fe26e98, true}}, // nb = 1.769f
+    };
+
     // log(x) constants
     static const table_t log_consts {
             {log_minus_inf, {0xff800000, true}},
@@ -2254,6 +2314,7 @@ void jit_uni_eltwise_injector_f32<isa, Wmm>::register_table_entries() {
                 case eltwise_logistic:
                 case eltwise_swish: exp_ = true; break;
                 case eltwise_gelu_erf: gelu_erf_ = true; break;
+                case eltwise_gelu_erf_2dts: gelu_erf_ = true; break;
                 case eltwise_gelu_tanh: gelu_tanh_ = true; break;
                 case eltwise_log: log_ = true; break;
                 case eltwise_soft_relu: soft_relu_ = true; break;
@@ -2313,8 +2374,13 @@ void jit_uni_eltwise_injector_f32<isa, Wmm>::register_table_entries() {
     if (need.soft_relu()) push_entries_of(soft_relu_consts);
     if (need.soft_relu()) push_entries_of(soft_relu_polynomial);
     if (need.gelu_tanh()) push_entries_of(gelu_tanh_consts);
-    if (need.gelu_erf()) push_entries_of(gelu_erf_consts);
-    if (need.gelu_erf()) push_entries_of(gelu_erf_polynomial);
+
+    if (need.gelu_erf()) {
+      push_entries_of(gelu_erf_consts);
+      push_entries_of(gelu_erf_polynomial);
+      push_entries_of(gelu_erf_2dts);
+    }
+
     if (need.log()) push_entries_of(log_consts);
     if (need.log()) push_entries_of(log_polynomial);
     if (need.log()) push_entries_of(log_predefined_values);
diff --git a/src/cpu/x64/injectors/jit_uni_eltwise_injector.hpp b/src/cpu/x64/injectors/jit_uni_eltwise_injector.hpp
index 54de22c01..0093b9339 100644
--- a/src/cpu/x64/injectors/jit_uni_eltwise_injector.hpp
+++ b/src/cpu/x64/injectors/jit_uni_eltwise_injector.hpp
@@ -40,22 +40,39 @@ struct static_params_t {
             Xbyak::Reg64 p_table = Xbyak::util::rax,
             Xbyak::Opmask k_mask = Xbyak::Opmask(1), bool is_fwd = true,
             bool use_dst = false, bool preserve_vmm = true,
-            bool preserve_p_table = true)
+            bool preserve_p_table = true,
+            Xbyak::Reg64 p_param = Xbyak::util::rdi,
+            ssize_t dynamic_scale_off = -1)
         : save_state(save_state)
         , p_table(p_table)
+        , p_param(p_param)
         , k_mask(k_mask)
         , is_fwd(is_fwd)
         , use_dst(use_dst)
         , preserve_vmm(preserve_vmm)
-        , preserve_p_table(preserve_p_table) {}
+        , preserve_p_table(preserve_p_table)
+        , dynamic_scale_off(dynamic_scale_off) {}
+
+    static_params_t(size_t dynamic_scale_off)
+        : save_state(true)
+        , p_table(Xbyak::util::rax)
+        , p_param(Xbyak::util::rdi)
+        , k_mask(Xbyak::Opmask(1))
+        , is_fwd(true)
+        , use_dst(false)
+        , preserve_vmm(true)
+        , preserve_p_table(true)
+        , dynamic_scale_off(dynamic_scale_off) {}
 
     bool save_state;
     Xbyak::Reg64 p_table;
+    Xbyak::Reg64 p_param;
     Xbyak::Opmask k_mask;
     bool is_fwd;
     bool use_dst;
     bool preserve_vmm;
     bool preserve_p_table;
+    ssize_t dynamic_scale_off;
 };
 
 /*
@@ -96,14 +113,19 @@ struct jit_uni_eltwise_injector_f32 {
             Xbyak::Reg64 p_table = Xbyak::util::rax,
             Xbyak::Opmask k_mask = Xbyak::Opmask(1), bool is_fwd = true,
             bool use_dst = false, bool preserve_vmm = true,
-            bool preserve_p_table = true)
+            bool preserve_p_table = true,
+            // HACK
+            Xbyak::Reg64 p_param = Xbyak::util::rdi,
+            ssize_t dynamic_scale_off = -1)
         : alg_(alg)
         , alpha_(alpha)
         , beta_(beta)
         , scale_(scale)
+        , dynamic_scale_off(dynamic_scale_off)
         , h(host)
         , save_state_(save_state)
         , p_table(p_table)
+        , p_param(p_param)
         , k_mask(k_mask)
         , is_fwd_(is_fwd)
         , use_dst_(use_dst)
@@ -119,10 +141,13 @@ struct jit_uni_eltwise_injector_f32 {
             bool save_state = true, Xbyak::Reg64 p_table = Xbyak::util::rax,
             Xbyak::Opmask k_mask = Xbyak::Opmask(1), bool is_fwd = true,
             bool use_dst = false, bool preserve_vmm = true,
-            bool preserve_p_table = true)
+            bool preserve_p_table = true,
+            Xbyak::Reg64 p_param = Xbyak::util::rdi,
+            ssize_t dynamic_scale_off = -1)
         : jit_uni_eltwise_injector_f32(host, eltwise.alg, eltwise.alpha,
                 eltwise.beta, eltwise.scale, save_state, p_table, k_mask,
-                is_fwd, use_dst, preserve_vmm, preserve_p_table) {}
+                is_fwd, use_dst, preserve_vmm, preserve_p_table,
+                p_param, dynamic_scale_off) {}
 
     void compute_vector_range(size_t start_idx, size_t end_idx);
     void compute_vector_range(const injector_utils::vmm_index_set_t &vmm_idxs);
@@ -135,11 +160,13 @@ private:
     const float alpha_;
     const float beta_;
     const float scale_;
+    const ssize_t dynamic_scale_off;
 
     jit_generator *const h;
 
     const bool save_state_;
     const Xbyak::Reg64 p_table;
+    const Xbyak::Reg64 p_param;
     const Xbyak::Opmask k_mask;
     const bool is_fwd_;
     const bool use_dst_;
@@ -219,6 +246,7 @@ private:
     void clip_compute_vector_fwd(const Vmm &vmm_src);
     void pow_compute_vector_fwd(const Vmm &vmm_src);
     void gelu_erf_compute_vector_fwd(const Vmm &vmm_src);
+    void gelu_erf_2dts_compute_vector_fwd(const Vmm &vmm_src);
     void round_compute_vector_fwd(const Vmm &vmm_src);
     void hardswish_compute_vector_fwd(const Vmm &vmm_src);
 
@@ -283,6 +311,10 @@ private:
         gelu_erf_one_over_sqrt_two, // 1.f / sqrtf(2.f)
         gelu_erf_one_over_sqrt_pi, // 1.f / sqrtf(pi) = 0.564190f
         gelu_erf_pol, // see correspondent table for float values
+        gelu_erf_a, // -0.2888f
+        gelu_erf_b, // 1.0217744f
+        gelu_erf_c, // 0.0962405432f
+        gelu_erf_nb, // 1.769f
         log_minus_inf, // -inf
         log_qnan, // qnan
         log_mantissa_mask, // gets mantissa bits
@@ -308,6 +340,10 @@ private:
         auto off = table_off(key, key_off_val_shift);
         return h->ptr[p_table + off];
     }
+    // HACK: Get scale in stack frame, signaled when p_param != p_table
+    Xbyak::Address stack_val(size_t off) {
+        return h->zword_b[p_param + off + 8];
+    }
 
     // we accept only 32bit hexadecimal table values to avoid any rounding
     using table_entry_val_t = uint32_t;
diff --git a/src/cpu/x64/injectors/jit_uni_postops_injector.cpp b/src/cpu/x64/injectors/jit_uni_postops_injector.cpp
index 32098e745..3fbefe202 100644
--- a/src/cpu/x64/injectors/jit_uni_postops_injector.cpp
+++ b/src/cpu/x64/injectors/jit_uni_postops_injector.cpp
@@ -66,7 +66,8 @@ jit_uni_postops_injector_t<isa, Vmm>::jit_uni_postops_injector_t(
                     jit_uni_eltwise_injector_f32<isa, Vmm>(host_,
                             post_op.eltwise, esp.save_state, esp.p_table,
                             esp.k_mask, esp.is_fwd, esp.use_dst,
-                            esp.preserve_vmm, esp.preserve_p_table));
+                            esp.preserve_vmm, esp.preserve_p_table,
+                            Xbyak::util::rdi, esp.dynamic_scale_off));
         } else if (post_op.is_binary()) {
             is_binary = true;
         }
diff --git a/src/cpu/x64/jit_brgemm_inner_product.cpp b/src/cpu/x64/jit_brgemm_inner_product.cpp
index 557196f5c..d8c86f119 100644
--- a/src/cpu/x64/jit_brgemm_inner_product.cpp
+++ b/src/cpu/x64/jit_brgemm_inner_product.cpp
@@ -73,6 +73,8 @@ status_t brgemm_inner_product_fwd_t<isa>::execute_forward(
     const memory_desc_wrapper weights_d(pd()->weights_md(0));
 
     DEFINE_SCALES_BUFFER(oscales);
+    auto* pf_scale = CTX_IN_MEM(const float *, DNNL_ARG_SCALE);
+    auto final_scale = (pf_scale == nullptr) ? 1.f : *pf_scale;
 
     const auto &jbgp = pd()->jbgp_;
     const bool is_f32 = everyone_is(f32, jbgp.src_dt, jbgp.wei_dt, jbgp.dst_dt);
@@ -213,6 +215,7 @@ status_t brgemm_inner_product_fwd_t<isa>::execute_forward(
                 const brgemm_post_ops_data_t post_ops_data {
                         static_cast<const void *>(ptr_bias),
                         &oscales[jbgp.is_oc_scale * oc],
+                        final_scale,
                         post_ops_binary_rhs_arg_vec.data(),
                         static_cast<size_t>(oc), 0, dst};
 
@@ -256,6 +259,7 @@ status_t brgemm_inner_product_fwd_t<isa>::execute_forward(
                 const brgemm_post_ops_data_t post_ops_data {
                         static_cast<const void *>(ptr_bias),
                         &oscales[jbgp.is_oc_scale * oc],
+                        final_scale,
                         post_ops_binary_rhs_arg_vec.data(),
                         static_cast<size_t>(oc), 0, dst};
 
@@ -449,6 +453,7 @@ status_t brgemm_inner_product_fwd_t<isa>::execute_forward(
                             const brgemm_post_ops_data_t post_ops_data {
                                     static_cast<const void *>(ptr_bias),
                                     &oscales[jbgp.is_oc_scale * oc],
+                                    final_scale,
                                     post_ops_binary_rhs_arg_vec.data(),
                                     static_cast<size_t>(oc), 0, dst, 0, nullptr,
                                     nullptr, nullptr, true /* skip_accm */};
diff --git a/src/cpu/x64/jit_brgemm_inner_product.hpp b/src/cpu/x64/jit_brgemm_inner_product.hpp
index e988ffd2a..4dd666eb0 100644
--- a/src/cpu/x64/jit_brgemm_inner_product.hpp
+++ b/src/cpu/x64/jit_brgemm_inner_product.hpp
@@ -49,6 +49,17 @@ struct brgemm_inner_product_fwd_t : public primitive_t {
         DECLARE_COMMON_PD_T(JIT_IMPL_NAME_HELPER("brgemm:", isa, ""),
                 brgemm_inner_product_fwd_t);
 
+        arg_usage_t arg_usage(int arg) const override {
+            if (utils::one_of(arg, DNNL_ARG_SRC, DNNL_ARG_WEIGHTS, DNNL_ARG_SCALE))
+                return arg_usage_t::input;
+
+            if (arg == DNNL_ARG_BIAS && with_bias()) return arg_usage_t::input;
+
+            if (arg == DNNL_ARG_DST) return arg_usage_t::output;
+
+            return primitive_desc_t::arg_usage(arg);
+        }
+
         status_t init(engine_t *engine) {
             using namespace utils;
             using namespace data_type;
@@ -109,6 +120,8 @@ struct brgemm_inner_product_fwd_t : public primitive_t {
                         jbgp_.wei_dt, false, false, brgemm_row_major, alpha,
                         vbeta, jbgp_.LDA, jbgp_.LDB, jbgp_.LDC, vM, vN, vK));
 
+                adjust_compensation(&brg);
+
                 auto LDD = jbgp_.oc_without_padding;
                 CHECK(brgemm_desc_set_postops(
                         &brg, attr(), &dst_md_, LDD, jbgp_.bia_dt));
@@ -169,6 +182,24 @@ struct brgemm_inner_product_fwd_t : public primitive_t {
 
         brgemm_t brg_descs_[brgemm_inner_product_utils::max_num_brg_kernels_ip];
         jit_brgemm_primitive_conf_t jbgp_;
+    private:
+        // HACK use forward training signal pre-compensation
+        bool skip_compensation() {
+            return desc_.prop_kind == prop_kind::forward_training;
+        }
+
+        // HACK, if forward training with eltwise enabled
+        bool req_pre_compensation() {
+            return desc_.prop_kind == prop_kind::forward_training
+                && jbgp_.with_eltwise;
+        }
+
+        void adjust_compensation(brgemm_t *brg) {
+            brg->skip_input_s8_compensation = brg->req_s8s8_compensation
+                && skip_compensation();
+
+            brg->req_pre_compensation = req_pre_compensation();
+        }
     };
 
     brgemm_inner_product_fwd_t(const pd_t *apd) : primitive_t(apd) {}
diff --git a/src/cpu/x64/jit_brgemm_post_ops.hpp b/src/cpu/x64/jit_brgemm_post_ops.hpp
index 510bda80c..90282f7a1 100644
--- a/src/cpu/x64/jit_brgemm_post_ops.hpp
+++ b/src/cpu/x64/jit_brgemm_post_ops.hpp
@@ -701,7 +701,7 @@ private:
         auto zmm_ubound = Xbyak::Zmm(30);
         if (dt_requires_saturation) {
             init_saturate_f32(zmm_lbound, zmm_ubound, reg_tmp_gpr,
-                    data_type::f32, brg.dt_d);
+                    data_type::f32, brg.dt_d, true);
         }
 
         if (brg.is_bf16_emu) bf16_emu_->init_vcvtneps2bf16();
diff --git a/src/cpu/x64/jit_gemm_inner_product_utils.cpp b/src/cpu/x64/jit_gemm_inner_product_utils.cpp
index 2aefc51f7..f1aad6d7d 100644
--- a/src/cpu/x64/jit_gemm_inner_product_utils.cpp
+++ b/src/cpu/x64/jit_gemm_inner_product_utils.cpp
@@ -43,7 +43,7 @@ struct jit_pp_kernel_t : public pp_kernel_t, public jit_generator {
 
     jit_pp_kernel_t(size_t OC, size_t MB, dim_t dst_mb_stride,
             const primitive_attr_t *attr, data_type_t bias_dt,
-            data_type_t acc_dt, const memory_desc_t *dst_md, bool skip_sum);
+            data_type_t acc_dt, const memory_desc_t *dst_md, bool skip_sum, bool pcomp = false);
 
     void operator()(void *dst, const void *acc, const char *bias,
             const float *scales, size_t start, size_t dst_logical_off,
@@ -159,6 +159,7 @@ private:
     // Will be assigned in constructor
     Vmm vreg_zero, vreg_saturation_ubound, vreg_scale, vreg_sum_scale,
             vreg_sum_zp, vreg_dst_zero_points;
+    Vmm Vreg_compensation;
 
     const Xbyak::Reg64 eltwise_reserved_gpr_ = r11;
     const Xbyak::Opmask eltwise_reserved_opmask_ = k2;
@@ -266,14 +267,19 @@ private:
 template <cpu_isa_t isa>
 jit_pp_kernel_t<isa>::jit_pp_kernel_t(size_t OC, size_t MB, dim_t dst_mb_stride,
         const primitive_attr_t *attr, data_type_t bias_dt, data_type_t acc_dt,
-        const memory_desc_t *dst_md, bool skip_sum)
+        const memory_desc_t *dst_md, bool skip_sum, bool pcomp)
     : pp_kernel_t(
             OC, MB, dst_mb_stride, attr, bias_dt, acc_dt, dst_md, skip_sum) {
     assert(IMPLICATION(this->dst_data_type_ == bf16, mayiuse(avx512_core)));
 
     if (this->do_scale_) vreg_scale = Vmm(idx_compute_vreg_start_++);
 
-    if (this->dst_data_type_ == u8) vreg_zero = Vmm(idx_compute_vreg_start_++);
+    if (this->dst_data_type_ == data_type::u8
+        || this->dst_data_type_==data_type::s8) {
+        vreg_zero = Vmm(idx_compute_vreg_start_++);
+        if (this->do_precompensation)
+          Vreg_compensation = Vmm(idx_compute_vreg_start_ ++);
+    }
     if (utils::one_of(this->dst_data_type_, u8, s8, s32))
         vreg_saturation_ubound = Vmm(idx_compute_vreg_start_++);
 
@@ -555,7 +561,18 @@ void jit_pp_kernel_t<isa>::cvt_and_store(const Xbyak::Zmm v,
     auto v_src = tail ? v | kreg_rem_mask : v;
     const Xbyak::Address dst = get_address(arg_num, off);
     switch (dt) {
-        case s8: vpmovsdb(dst, v_src); break;
+        case s8: {
+          auto v_xmm = Xmm(v.getIdx());
+          auto dst_k = tail ? dst | kreg_rem_mask : dst;
+          if (this->do_precompensation) {
+            vpmovsdb(v_xmm, v);
+            vpxord(v_xmm, v_xmm, Xmm(Vreg_compensation.getIdx()));
+            vmovdqu8(dst_k, v_xmm);
+          } else {
+            vpmovsdb(dst, v_src);
+          }
+        }
+        break;
         case u8: vpmovusdb(dst, v_src); break;
         case f32:
         case s32: uni_vmovups(dst, v_src); break;
@@ -1097,6 +1114,11 @@ void jit_pp_kernel_t<isa>::generate() {
         mov(reg_oc, ptr[reg_param + PARAM_OFF(dst_zero_points)]);
         uni_vbroadcastss(vreg_dst_zero_points, ptr[reg_oc]);
     }
+    // HACK, do precompensation
+    if (this->do_precompensation) {
+        mov(reg_oc.cvt32(), 0x80808080);
+        vpbroadcastd(Vreg_compensation, reg_oc.cvt32());
+    }
     if (this->runtime_oc())
         mov(reg_oc, ptr[reg_param + PARAM_OFF(oc)]);
     else
@@ -1155,7 +1177,7 @@ void jit_pp_kernel_t<isa>::generate() {
     }
 
     init_saturate_f32(vreg_zero, vreg_saturation_ubound, reg_tmp_comp, f32,
-            this->dst_data_type_);
+            this->dst_data_type_, true);
 
     // at least 2 blocks of mb within vlen
     bool dim_restrict = !this->runtime_oc() && !this->runtime_mb()
@@ -1221,13 +1243,13 @@ void jit_pp_kernel_t<isa>::operator()(void *dst, const void *acc,
 
 pp_kernel_t *jit_pp_kernel_create(size_t OC, size_t MB, dim_t dst_mb_stride,
         const primitive_attr_t *attr, data_type_t bias_dt, data_type_t acc_dt,
-        const memory_desc_t *dst_md, bool skip_sum) {
+        const memory_desc_t *dst_md, bool skip_sum, bool pcomp) {
     if (mayiuse(avx512_core_bf16)) {
         return new jit_pp_kernel_t<avx512_core_bf16>(
-                OC, MB, dst_mb_stride, attr, bias_dt, acc_dt, dst_md, skip_sum);
+                OC, MB, dst_mb_stride, attr, bias_dt, acc_dt, dst_md, skip_sum, pcomp);
     } else if (mayiuse(avx512_core)) {
         return new jit_pp_kernel_t<avx512_core>(
-                OC, MB, dst_mb_stride, attr, bias_dt, acc_dt, dst_md, skip_sum);
+                OC, MB, dst_mb_stride, attr, bias_dt, acc_dt, dst_md, skip_sum, pcomp);
     } else if (mayiuse(avx2)) {
         return new jit_pp_kernel_t<avx2>(
                 OC, MB, dst_mb_stride, attr, bias_dt, acc_dt, dst_md, skip_sum);
diff --git a/src/cpu/x64/jit_gemm_inner_product_utils.hpp b/src/cpu/x64/jit_gemm_inner_product_utils.hpp
index 6f77e0d4f..1de04b81e 100644
--- a/src/cpu/x64/jit_gemm_inner_product_utils.hpp
+++ b/src/cpu/x64/jit_gemm_inner_product_utils.hpp
@@ -28,7 +28,7 @@ namespace inner_product_utils {
 cpu::inner_product_utils::pp_kernel_t *jit_pp_kernel_create(size_t OC,
         size_t MB, dim_t dst_mb_stride, const primitive_attr_t *attr,
         data_type_t bias_dt, data_type_t acc_dt, const memory_desc_t *dst_md,
-        bool skip_sum);
+        bool skip_sum, bool pcomp = false);
 
 constexpr cpu_isa_t jit_pp_kernel_supported_isa() {
     return sse41;
diff --git a/src/cpu/x64/jit_generator.hpp b/src/cpu/x64/jit_generator.hpp
index eb8460272..6aaae1141 100644
--- a/src/cpu/x64/jit_generator.hpp
+++ b/src/cpu/x64/jit_generator.hpp
@@ -1605,7 +1605,8 @@ public:
      */
     template <typename Vmm>
     void init_saturate_f32(Vmm vmm_lbound, Vmm vmm_ubound, Xbyak::Reg64 reg_tmp,
-            data_type_t idt, data_type_t odt, bool force_lbound = false) {
+            data_type_t idt, data_type_t odt, bool force_lbound = true,
+            int8_t lbound_off = 1) {
         using namespace data_type;
         if (!((idt == f32) && utils::one_of(odt, u8, s8, s32))) return;
 
@@ -1629,7 +1630,8 @@ public:
         if (odt == u8)
             uni_vpxor(vmm_lbound, vmm_lbound, vmm_lbound);
         else if (force_lbound) {
-            const float saturation_lbound = odt == s8 ? INT8_MIN : INT32_MIN;
+            const float saturation_lbound = odt == s8 ? INT8_MIN + lbound_off
+                                                      : INT32_MIN + lbound_off;
             init_vmm(vmm_lbound, saturation_lbound);
         }
 
@@ -1639,7 +1641,7 @@ public:
 
     template <typename Vmm>
     void saturate_f32(const Vmm &vmm, const Vmm &vmm_lbound,
-            const Vmm &vmm_ubound, data_type_t odt, bool force_lbound = false) {
+            const Vmm &vmm_ubound, data_type_t odt, bool force_lbound = true) {
         // This function is used to saturate to odt in f32 before converting
         // to s32 in order to avoid bad saturation due to cvtps2dq
         // behavior (it returns INT_MIN if the f32 is out of the
